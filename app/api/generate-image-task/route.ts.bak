import { NextRequest, NextResponse } from 'next/server';
import { OpenAI } from 'openai';
import { v4 as uuid } from 'uuid';
import { createClient } from '@/utils/supabase/server';
import { createAdminClient } from '@/utils/supabase/admin';
import { getApiConfig } from '@/utils/env';
import { updateCredits } from '@/utils/credit-service';
import { estimateBase64Size } from '@/utils/image/image2Base64';
import { cookies } from 'next/headers';
import { createSecureClient, getCurrentUser } from '@/app/api/auth-middleware';
import { ChatCompletionMessageParam, ChatCompletionContentPart } from 'openai/resources';
import { ChatCompletionUserMessageParam, ChatCompletionSystemMessageParam } from 'openai/resources/chat/completions';

// 图片大小限制
const MAX_REQUEST_SIZE_MB = 12; // 12MB
const MAX_IMAGE_SIZE_MB = 8;    // 8MB
const MB_TO_BYTES = 1024 * 1024;

// 预处理请求，检查请求大小
async function checkRequestSize(request: NextRequest): Promise<{isValid: boolean, error?: string}> {
  try {
    // 获取Content-Length头
    const contentLength = request.headers.get('Content-Length');
    
    if (contentLength) {
      const sizeInMB = parseInt(contentLength) / MB_TO_BYTES;
      
      if (sizeInMB > MAX_REQUEST_SIZE_MB) {
        console.error(`请求体过大: ${sizeInMB.toFixed(2)}MB，超过限制(${MAX_REQUEST_SIZE_MB}MB)`);
        return {
          isValid: false,
          error: `请求体过大(${sizeInMB.toFixed(1)}MB)，超过限制(${MAX_REQUEST_SIZE_MB}MB)，请减小图片尺寸或降低质量后重试`
        };
      }
    }
    
    return { isValid: true };
  } catch (error) {
    console.error('检查请求大小出错:', error);
    return { isValid: true }; // 出错时放行，由后续步骤处理
  }
}

// 检查图片大小
function checkImageSize(imageBase64: string): {isValid: boolean, error?: string} {
  try {
    // 计算图片大小
    const sizeKB = estimateBase64Size(imageBase64);
    const sizeInMB = sizeKB / 1024;
    
    if (sizeInMB > MAX_IMAGE_SIZE_MB) {
      console.error(`图片过大: ${sizeInMB.toFixed(2)}MB，超过限制(${MAX_IMAGE_SIZE_MB}MB)`);
      return {
        isValid: false,
        error: `图片过大(${sizeInMB.toFixed(1)}MB)，超过限制(${MAX_IMAGE_SIZE_MB}MB)，请减小图片尺寸或降低质量后重试`
      };
    }
    
    return { isValid: true };
  } catch (error) {
    console.error('检查图片大小出错:', error);
    return { isValid: true }; // 出错时放行，由后续步骤处理
  }
}

// 定义TuziConfig类型
interface TuziConfig {
  apiUrl: string;
  apiKey: string;
  model: string;
  isConfigComplete: boolean;
}

// 日志工具函数
const logger = {
  debug: (message: string) => {
    console.debug(`[图片任务调试] ${message}`);
  },
  info: (message: string) => {
    console.log(`[图片任务] ${message}`);
  },
  warn: (message: string) => {
    console.warn(`[图片任务警告] ${message}`);
  },
  error: (message: string) => {
    console.error(`[图片任务错误] ${message}`);
  },
  // 增加性能计时日志
  timing: (startTime: number, label: string) => {
    const duration = Date.now() - startTime;
    console.log(`[图片任务计时] ${label}: ${duration}ms`);
  },
  // 增加任务状态转换日志
  stateChange: (taskId: string, fromState: string, toState: string) => {
    console.log(`[图片任务状态] 任务${taskId}状态从${fromState}变更为${toState}`);
  }
};

// 创建图资API客户端 - 按照tuzi-openai.md的方式
function createTuziClient() {
  // 获取环境配置
  const apiConfig = getApiConfig('tuzi') as TuziConfig;
  
  // 优先使用环境变量中的配置
  const apiKey = apiConfig.apiKey || process.env.OPENAI_API_KEY;
  const baseURL = apiConfig.apiUrl || process.env.OPENAI_BASE_URL || "https://api.tu-zi.com/v1";
  
  // 设置gpt-4o-all作为默认模型
  let imageModel = "gpt-4o-all"; 
  
  // 记录环境变量配置情况，但始终使用gpt-4o-all
  if (process.env.OPENAI_IMAGE_MODEL) {
    logger.info(`环境变量中配置的模型: ${process.env.OPENAI_IMAGE_MODEL}，但将使用gpt-4o-all`);
  } else {
    logger.info(`未找到OPENAI_IMAGE_MODEL环境变量，将使用gpt-4o-all`);
  }
  
  logger.info(`创建图资API客户端，使用BASE URL: ${baseURL}`);
  logger.debug(`API密钥状态: ${apiKey ? '已配置' : '未配置'} (长度: ${apiKey?.length || 0})`);
  logger.debug(`使用统一图像生成模型: ${imageModel}`);
  
  if (!apiKey) {
    logger.error('API密钥未配置，请检查环境变量OPENAI_API_KEY');
    throw new Error('API密钥未配置');
  }
  
  // 设置API超时时间 - 默认60秒
  const apiTimeout = parseInt(process.env.OPENAI_TIMEOUT || '60000');
  logger.debug(`API超时设置: ${apiTimeout}ms`);
  
  // 设置API最大重试次数 - 默认2次
  const maxRetries = parseInt(process.env.OPENAI_MAX_RETRIES || '2');
  logger.debug(`API最大重试次数: ${maxRetries}次`);
  
  // 返回配置的客户端以及模型配置
  return {
    client: new OpenAI({
      apiKey: apiKey,
      baseURL: baseURL,
      timeout: apiTimeout,
      maxRetries: maxRetries
    }),
    imageModel: imageModel
  };
}

// 保存生成历史到数据库
async function saveGenerationHistory(
  supabase: any, 
  userId: string, 
  imageUrl: string, 
  prompt: string, 
  style?: string | null, 
  aspectRatio?: string | null,
  standardAspectRatio?: string | null
) {
  try {
    // 检查表结构是否包含provider字段
    logger.debug(`准备保存历史记录，先检查表结构`);
    
    // 首先查询表结构
    const { data: tableInfo, error: tableError } = await supabase
      .from('ai_images_creator_history')
      .select('*')
      .limit(1);
    
    if (tableError) {
      logger.warn(`检查表结构失败: ${tableError.message}`);
    }
    
    // 始终使用gpt-4o-all作为模型名称
    const modelUsed = 'gpt-4o-all';
    
    // 构建基本数据对象
    const historyData: any = {
        user_id: userId,
        image_url: imageUrl,
      prompt: prompt || '',
      style: style || null,
      aspect_ratio: aspectRatio || null,
      standard_aspect_ratio: standardAspectRatio || null,
      model_used: modelUsed,
        status: 'completed',
        created_at: new Date().toISOString()
    };
    
    // 检查表结构，判断是否包含provider字段
    let hasProviderField = true;
    
    if (!tableError && tableInfo && tableInfo.length > 0) {
      const columns = Object.keys(tableInfo[0]);
      hasProviderField = columns.includes('provider');
      logger.debug(`表结构检查结果: provider字段${hasProviderField ? '存在' : '不存在'}`);
    }
    
    // 仅当确认有provider字段时添加
    if (hasProviderField) {
      historyData.provider = 'tuzi';
    }
    
    // 保存到历史记录表
    logger.debug(`开始插入历史记录，数据: ${JSON.stringify(historyData)}`);
    const { error } = await supabase
      .from('ai_images_creator_history')
      .insert([historyData]);
      
    if (error) {
      logger.error(`保存生成历史失败: ${error.message}`);
      
      // 如果错误与provider字段有关，尝试移除此字段后重新插入
      if (error.message.toLowerCase().includes('provider')) {
        logger.info(`检测到provider字段问题，尝试移除此字段后重新插入`);
        delete historyData.provider;
        
        const { error: retryError } = await supabase
          .from('ai_images_creator_history')
          .insert([historyData]);
          
        if (retryError) {
          logger.error(`移除provider字段后仍插入失败: ${retryError.message}`);
          return false;
        } else {
          logger.info(`移除provider字段后成功保存历史记录`);
          return true;
        }
      }
      
      return false;
    }
    
    logger.info(`成功保存图片生成历史记录`);
    return true;
  } catch (err) {
    logger.error(`保存历史记录出错: ${err instanceof Error ? err.message : String(err)}`);
    // 即使保存失败也不应阻止主流程
    return false;
  }
}

// 从聊天内容中提取图片URL
function extractImageUrl(content: string): string | null {
  // 记录完整内容用于调试
  logger.debug(`尝试从内容中提取URL: ${content.substring(0, 300)}...`);
  
  // 尝试提取各种格式的图片URL
  const patterns = [
    // 常规图片URL
    /(https?:\/\/[^\s"'<>]+\.(jpe?g|png|gif|webp|bmp))/i,
    // 通用URL，可能是图片服务
    /(https?:\/\/[^\s"'<>]+\/[^\s"'<>]+\.(jpe?g|png|gif|webp|bmp))/i,
    // 带图片参数的URL
    /(https?:\/\/[^\s"'<>]+\?.*image.*=.*)/i,
    // Markdown图片链接
    /!\[.*?\]\((https?:\/\/[^\s)]+)\)/i,
    // HTML图片标签
    /<img.*?src=["'](https?:\/\/[^\s"'<>]+)["']/i,
    // 任何URL (最后尝试)
    /(https?:\/\/[^\s"'<>]+)/i
  ];
  
  // 逐个尝试各种模式
  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match && match[1]) {
      logger.debug(`从内容中使用模式 ${pattern} 提取到URL: ${match[1]}`);
      return match[1];
    }
  }
  
  logger.error(`未能提取到任何URL，原内容: ${content}`);
  return null;
}

// 进行点数更新，并发送事件
const notifyCreditsUpdate = async (userId: string, newCredits: number) => {
  try {
    // 使用点数服务的updateCredits通知前端
    updateCredits(newCredits);
    logger.info(`已触发点数更新事件, 用户: ${userId}, 新点数: ${newCredits}`);
    
    // 只进行一次延迟重试，不再使用多次重试机制
      setTimeout(() => {
        try {
          updateCredits(newCredits);
        logger.info(`重试触发点数更新事件, 用户: ${userId}, 新点数: ${newCredits}`);
        } catch (retryError) {
        logger.error(`重试触发点数更新事件失败: ${retryError instanceof Error ? retryError.message : String(retryError)}`);
      }
    }, 2000); // 延迟2秒进行单次重试
    
  } catch (eventError) {
    logger.error(`触发点数更新事件失败: ${eventError instanceof Error ? eventError.message : String(eventError)}`);
  }
};

// 验证图片数据格式 - 增强版
function validateImageData(imageData: string): boolean {
  try {
    // 基本格式检查
    if (!imageData || typeof imageData !== 'string') {
      logger.error('图片数据无效：为空或非字符串');
      return false;
    }
    
    logger.debug(`开始验证图片数据: 长度=${imageData.length}, 前缀=${imageData.substring(0, 30)}...`);
    
    // 检查前缀 - 标准验证
    if (!imageData.startsWith('data:image/')) {
      logger.error('图片数据格式错误: 缺少有效的data:image前缀');
      return false;  // 更严格的验证，要求必须有正确前缀
    }

    // 验证data URL格式
    const dataUrlRegex = /^data:(image\/[a-z]+);base64,/i;
    const match = imageData.match(dataUrlRegex);
    
    if (!match) {
      logger.error('图片数据格式不符合标准data URL格式');
      return false;
    }
    
    const mimeType = match[1].toLowerCase();
    logger.debug(`检测到MIME类型: ${mimeType}`);
    
    // 检查是否为支持的MIME类型
    const supportedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
    if (!supportedTypes.includes(mimeType)) {
      logger.warn(`检测到不常见的MIME类型: ${mimeType}, 但将继续处理`);
    }
    
    // 拆分并验证base64部分
    const parts = imageData.split(',');
    if (parts.length !== 2) {
      logger.error(`图片数据格式错误: 无法正确拆分base64部分, 找到${parts.length}个部分`);
      return false;
    }
    
      const base64Part = parts[1].trim();
    
    // 验证base64部分
    if (!base64Part || base64Part.length < 100) {
      logger.error(`base64部分异常: 长度=${base64Part.length}`);
        return false;
      }
      
    // 检查base64字符是否有效
    const validBase64Regex = /^[A-Za-z0-9+/=]+$/;
    // 只检查前1000和最后100个字符，避免检查整个大字符串
    const headPart = base64Part.substring(0, 1000);
    const tailPart = base64Part.substring(base64Part.length - 100);
    
    if (!validBase64Regex.test(headPart) || !validBase64Regex.test(tailPart)) {
      logger.error('base64部分包含无效字符');
      return false;
    }
    
    // 尝试解码部分数据验证base64编码的有效性
    try {
      // 只解码前1KB和最后100字节进行测试
      const testParts = [
        base64Part.substring(0, 1024),
        base64Part.substring(base64Part.length - 100)
      ];
      
      for (const testPart of testParts) {
      const buffer = Buffer.from(testPart, 'base64');
        if (buffer.length <= 0) {
          logger.error(`base64解码异常: 解码后长度为${buffer.length}`);
          return false;
        }
      }
      
      // 如果是JPEG，检查JPEG文件头(SOI: 0xFF, 0xD8)
      if (mimeType === 'image/jpeg') {
        const testBuffer = Buffer.from(base64Part.substring(0, 100), 'base64');
        if (testBuffer.length >= 2 && (testBuffer[0] !== 0xFF || testBuffer[1] !== 0xD8)) {
          logger.warn('JPEG数据缺少正确的文件头标记(SOI)，但将继续处理');
        }
      }
      
      // 如果是PNG，检查PNG文件头
      if (mimeType === 'image/png') {
        const testBuffer = Buffer.from(base64Part.substring(0, 100), 'base64');
        if (testBuffer.length >= 8 && 
            (testBuffer[0] !== 0x89 || testBuffer[1] !== 0x50 || 
             testBuffer[2] !== 0x4E || testBuffer[3] !== 0x47)) {
          logger.warn('PNG数据缺少正确的文件头标记，但将继续处理');
        }
      }
      
      logger.info(`图片数据验证通过: MIME类型=${mimeType}, base64长度=${base64Part.length}`);
      return true;
    } catch (decodeError) {
      logger.error(`解码图片数据出错: ${decodeError instanceof Error ? decodeError.message : String(decodeError)}`);
      return false;
    }
  } catch (error) {
    logger.error(`验证图片数据时出现未预期错误: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

// 带重试的数据库操作
async function retryDatabaseOperation<T>(
  operation: () => Promise<T>,
  maxRetries: number = 3,
  initialDelay: number = 1000
): Promise<T> {
  let lastError: any;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error;
      
      // 只有在不是最后一次尝试时才延迟和重试
      if (attempt < maxRetries - 1) {
        const delay = initialDelay * Math.pow(2, attempt);
        logger.warn(`数据库操作失败，等待${delay}ms后重试(${attempt + 1}/${maxRetries}): ${error instanceof Error ? error.message : String(error)}`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  // 所有重试都失败
  throw lastError;
}

// 增强错误记录函数，提供详细的错误信息
function logEnhancedError(context: string, error: any, taskId?: string) {
  const errorMsg = error instanceof Error ? error.message : String(error);
  const errorType = error instanceof Error ? error.constructor.name : 'Unknown';
  const errorStack = error instanceof Error ? error.stack : 'No stack trace';
  
  console.error(`[错误记录增强] ${context}:`);
  console.error(`- 任务ID: ${taskId || 'N/A'}`);
  console.error(`- 错误类型: ${errorType}`);
  console.error(`- 错误消息: ${errorMsg}`);
  console.error(`- 时间戳: ${new Date().toISOString()}`);
  console.error(`- 堆栈跟踪: ${errorStack || 'No stack trace'}`);
  
  // 记录错误到单独的日志文件或服务
  try {
    // 添加额外上下文信息
    const diagnosticInfo = {
      timestamp: new Date().toISOString(),
      taskId,
      errorType,
      errorMessage: errorMsg,
      stackTrace: errorStack,
      context,
      environment: {
        nodeEnv: process.env.NODE_ENV,
        openaiModel: process.env.OPENAI_IMAGE_MODEL,
        baseUrl: (process.env.OPENAI_BASE_URL || '').replace(/\/v1\/?$/, '') // 移除可能的API版本
      }
    };
    
    // 在开发环境中打印完整诊断信息
    if (process.env.NODE_ENV === 'development') {
      console.log('详细诊断信息:', JSON.stringify(diagnosticInfo, null, 2));
    }
    
    // 这里可以添加发送到错误监控服务的代码
    // 例如Sentry、LogRocket等
  } catch (loggingError) {
    console.error('记录增强错误信息失败:', loggingError);
  }
  
  return errorMsg; // 返回原始错误消息，便于后续处理
}

// 添加任务通知函数
async function notifyTaskUpdate(taskId: string, status: string, imageUrl?: string, error?: string) {
  try {
    // 获取API密钥
    const apiKey = process.env.INTERNAL_API_KEY || 'development-key';
    
    // 尝试调用内部API触发通知
    const notifyResponse = await fetch(`${process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'}/api/notify-task-update`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': apiKey
      },
      body: JSON.stringify({
        taskId,
        status,
        imageUrl,
        error,
        timestamp: new Date().toISOString()
      })
    });
    
    if (notifyResponse.ok) {
      logger.info(`已成功触发任务${taskId}的${status}通知`);
      return true;
    } else {
      const errorText = await notifyResponse.text();
      logger.error(`触发任务通知失败: ${errorText}`);
      return false;
    }
  } catch (error) {
    logger.error(`发送任务通知异常: ${error instanceof Error ? error.message : String(error)}`);
    // 尝试备用通知方法 - 直接插入数据库记录
    try {
      const supabaseAdmin = await createAdminClient();
      await supabaseAdmin
        .from('task_status_updates')
        .insert({
          task_id: taskId,
          status: status,
          image_url: imageUrl || null,
          error_message: error || null,
          created_at: new Date().toISOString()
        });
      logger.info(`使用备用方法记录任务${taskId}的${status}通知`);
      return true;
    } catch (dbError) {
      logger.error(`备用通知方法也失败: ${dbError instanceof Error ? dbError.message : String(dbError)}`);
      return false;
    }
  }
}

// 创建图像URL验证函数
function isValidImageUrl(url: string): boolean {
  // 验证URL格式
  try {
    // 必须是有效的URL
    const parsedUrl = new URL(url);
    
    // 记录URL信息辅助调试
    logger.debug(`验证图片URL: ${url}`);
    logger.debug(`URL组成部分: 协议=${parsedUrl.protocol}, 主机=${parsedUrl.hostname}, 路径=${parsedUrl.pathname}`);
    
    // 必须是HTTP或HTTPS
    if (!parsedUrl.protocol.startsWith('http')) {
      logger.error(`URL协议不是http或https: ${parsedUrl.protocol}`);
      return false;
    }
    
    // 检查常见图片服务商域名
    const knownImageDomains = [
      'openai.com', 'cloudfront.net', 'imgix.net', 'googleapis.com', 
      'googleusercontent.com', 'bing.com', 'tu-zi.com', 'cdn.openai.com', 
      'azureedge.net', 'storage.googleapis.com', 's3.amazonaws.com'
    ];
    
    // 如果是已知图片服务商，直接通过
    for (const domain of knownImageDomains) {
      if (parsedUrl.hostname.includes(domain)) {
        logger.debug(`检测到已知图片服务域名: ${domain}`);
        return true;
      }
    }
    
    // 多层次的检查 - 优先级从高到低
    
    // 1. 路径以常见图片扩展名结尾
    if (/\.(jpe?g|png|gif|webp|svg|bmp)($|\?)/i.test(parsedUrl.pathname)) {
      logger.debug(`URL包含常见图片扩展名: ${parsedUrl.pathname}`);
      return true;
    }
    
    // 2. 路径包含常见图片相关路径
    if (/\/images?\//i.test(parsedUrl.pathname) || 
        /\/(image|picture|photo|generated-image|file|content|media|asset|upload)/i.test(parsedUrl.pathname)) {
      logger.debug(`URL包含图片相关路径: ${parsedUrl.pathname}`);
      return true;
    }
    
    // 3. URL参数包含图片相关标识
    if (/[?&](image|img|picture|photo|file|media)=/i.test(parsedUrl.search)) {
      logger.debug(`URL参数包含图片相关参数: ${parsedUrl.search}`);
      return true;
    }
    
    // 4. 检查特定格式的图片服务URL
    if (/\/v\d+\/images\/generations\//i.test(parsedUrl.pathname)) {
      logger.debug(`URL匹配特定图片生成服务格式: ${parsedUrl.pathname}`);
      return true;
    }
    
    // 未满足任何已知图片URL模式
    logger.warn(`URL不符合任何已知图片URL格式: ${url}`);
    return false;
  } catch (e) {
    logger.error(`URL格式验证失败: ${e instanceof Error ? e.message : String(e)}`);
    return false;
  }
}

export async function POST(request: NextRequest) {
  try {
    // 预检查请求大小
    const sizeCheck = await checkRequestSize(request);
    if (!sizeCheck.isValid) {
      return NextResponse.json({ 
        status: 'failed',
        error: sizeCheck.error,
        suggestion: '请使用较小的图片或降低图片质量后重试'
      }, { status: 413 });
    }
    
    // 解析请求体
    const body = await request.json().catch((error) => {
      console.error('解析请求JSON失败:', error);
      throw new Error('无效的请求格式，无法解析JSON数据');
    });
    
    const { prompt, image, style, aspectRatio, standardAspectRatio } = body;
    
    // 验证必要参数
    if (!prompt && !image) {
      return NextResponse.json({
        status: 'failed',
        error: '提示词和图片至少需要提供一项'
      }, { status: 400 });
    }
    
    // 检查图片大小
    if (image) {
      const imageCheck = checkImageSize(image);
      if (!imageCheck.isValid) {
        return NextResponse.json({
          status: 'failed',
          error: imageCheck.error,
          suggestion: '请使用较小的图片或降低图片质量后重试'
        }, { status: 413 });
      }
    }
    
    // 验证用户身份 - 使用更可靠的认证方法
    logger.debug('开始验证用户身份...');
    
    // 使用安全客户端获取用户信息
    const { supabase } = await createSecureClient();
    const currentUser = await getCurrentUser(supabase);
    
    if (!currentUser) {
      logger.error('未找到用户信息，认证失败');
      return NextResponse.json({
        status: 'failed',
        error: '认证失败，请重新登录',
        code: 'auth_required'
      }, { status: 401 });
    }
    
    logger.info(`用户 ${currentUser.id} 认证成功`);
    
    // 检查用户点数
    const { data: credits, error: creditsError } = await supabase
      .from('ai_images_creator_credits')
      .select('credits')
      .eq('user_id', currentUser.id)
      .single();
    
    // 错误处理 - 查询点数失败
    if (creditsError) {
      console.error('获取用户点数失败:', creditsError.message);
      return NextResponse.json({
        status: 'failed',
        error: '无法获取用户点数信息',
        suggestion: '请刷新页面或重新登录后再试'
      }, { status: 500 });
    }
    
    // 检查用户点数是否足够
    if (!credits || credits.credits < 1) {
      return NextResponse.json({
        status: 'failed',
        error: '点数不足，无法生成图片',
        code: 'insufficient_credits',
        suggestion: '请充值点数后再试'
      }, { status: 402 });
    }
    
    // 生成任务ID
    const taskId = uuid();
    
    // 在数据库中创建任务记录
    const supabaseAdmin = await createAdminClient();
    
    try {
      // 扣除用户1点积分
      const { error: updateError } = await supabaseAdmin
        .from('ai_images_creator_credits')
        .update({
          credits: credits.credits - 1,
          updated_at: new Date().toISOString()
        })
        .eq('user_id', currentUser.id);
      
      if (updateError) {
        console.error('扣除用户点数失败:', updateError.message);
        throw new Error('扣除用户点数失败');
      }
      
      // 创建任务记录
      const taskUUID = uuid();
      const { error: taskError } = await supabaseAdmin
        .from('image_tasks')
        .insert({
          id: taskUUID,
          user_id: currentUser.id,
          task_id: taskId,
          status: 'pending',
          prompt: prompt,
          image_base64: image || null,
          style: style || null,
          aspect_ratio: aspectRatio || null,
          provider: 'tuzi',
          model: 'gpt-4o-all',
          request_id: taskId,
          attempt_count: 0,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        });
      
      if (taskError) {
        console.error('创建任务记录失败:', taskError.message);
        throw new Error(`创建任务记录失败: ${taskError.message}`);
      }
      
      // 验证任务是否正确创建
      const { data: createdTask, error: checkTaskError } = await supabaseAdmin
        .from('image_tasks')
        .select('*')
        .eq('task_id', taskId)
        .single();
        
      if (checkTaskError || !createdTask) {
        console.error('验证任务创建失败:', checkTaskError?.message || '未找到任务记录');
        throw new Error(`任务验证失败: ${checkTaskError?.message || '未找到任务记录'}`);
      }
      
      logger.info(`成功创建并验证任务，ID: ${taskId}, UUID: ${taskUUID}`);
      
      // 直接进行图像生成 - 不等待异步过程
      try {
        // 创建OpenAI客户端
        const { client: openaiClient, imageModel } = createTuziClient();
        
        // 记录开始时间
        const startTime = Date.now();
        logger.info(`开始处理图像，任务ID: ${taskId}，使用模型: ${imageModel}`);
        logger.debug(`环境变量OPENAI_IMAGE_MODEL: ${process.env.OPENAI_IMAGE_MODEL || '未设置'}`);
        logger.debug(`环境变量OPENAI_MODEL: ${process.env.OPENAI_MODEL || '未设置'}`);
        
        // 定义消息结构
        let messages: ChatCompletionMessageParam[] = [];
        
        // 获取图片尺寸比例参数
        let size: "1024x1024" | "1792x1024" | "1024x1792" = "1024x1024"; // 默认尺寸
        let aspectRatioDescription = ""; // 比例描述文本
        
        // 根据请求参数和提示词确定合适的尺寸
        if (aspectRatio) {
          // 添加比例描述到提示词中
          aspectRatioDescription = `，保持${aspectRatio}的宽高比例`;
          
          // 根据实际图片比例决定输出尺寸
          logger.info(`检测到图片比例: ${aspectRatio}`);
          
          if (standardAspectRatio) {
            logger.info(`标准化比例: ${standardAspectRatio}`);
            
            // 根据标准化比例选择合适的DALL-E尺寸
            if (standardAspectRatio.includes('16:9') || standardAspectRatio.includes('4:3') || standardAspectRatio.includes('3:2')) {
              size = "1792x1024"; // 宽屏比例
              logger.info(`根据图片比例选择宽屏尺寸: ${size}`);
            } else if (standardAspectRatio.includes('9:16') || standardAspectRatio.includes('3:4') || standardAspectRatio.includes('2:3')) {
              size = "1024x1792"; // 高屏比例
              logger.info(`根据图片比例选择竖屏尺寸: ${size}`);
            } else {
              logger.info(`根据图片比例选择标准尺寸: ${size}`);
            }
          }
        }
        // 记录比例信息
        if (aspectRatio) {
          logger.info(`图片比例参数: aspectRatio=${aspectRatio}, standardAspectRatio=${standardAspectRatio || '未指定'}`);
        }

        // 使用单一用户消息，包含所有内容 - 严格按照tuzi-openai.md的模式
        // 创建用户消息内容数组
        const userMessageContent: Array<ChatCompletionContentPart> = [];
        
        // 保存最终提示词，用于记录
        let finalPrompt = prompt || "生成图像";
        
        if (image) {
          logger.info(`处理用户上传的图片，任务ID: ${taskId}`);
          
          try {
            // 改进图片数据处理 - 增强可靠性
            let imageData;
            
            // 处理图片数据...
            if (image.startsWith('data:image/')) {
              imageData = image;
            } else {
              // 为原始base64添加data URL前缀
              const mimeType = 'image/jpeg'; // 默认JPEG
              imageData = `data:${mimeType};base64,${image}`;
            }
            
            // 验证图片数据
            if (!imageData || imageData.length < 100) {
              throw new Error('图片数据无效');
            }
            
            // 先添加图片到消息内容
            userMessageContent.push({
              type: "image_url",
              image_url: {
                url: imageData
              }
            });
            
            // 再添加文本提示
            userMessageContent.push({
              type: "text",
              text: finalPrompt
            });
            
          } catch (imageProcessError) {
            logger.error(`图片处理过程中出错: ${imageProcessError instanceof Error ? imageProcessError.message : String(imageProcessError)}`);
            throw new Error(`无法处理图片数据: ${imageProcessError instanceof Error ? imageProcessError.message : String(imageProcessError)}`);
          }
        } else {
          // 没有图片时，只添加文本内容
          userMessageContent.push({
            type: "text",
            text: finalPrompt
          });
        }
        
        // 构建单一用户消息
        messages.push({
          role: 'user',
          content: userMessageContent
        });
        
        logger.debug(`构建消息完成，消息数组长度: ${messages.length}`);
        logger.debug(`消息内容项目数: ${userMessageContent.length}`);

        // 图像生成参数
        const quality = "hd"; // 使用高清质量，提高输出图像质量
        
        // 使用gpt-4o-all通过聊天API生成图像
        logger.info(`使用聊天API (gpt-4o-all)生成图片，提示词长度: ${finalPrompt.length}字符`);
        
        // 添加API请求开始时间记录
        const apiRequestStartTime = Date.now();
        
        // 执行API调用前验证消息结构
        if (messages.length < 1) {
          logger.error('消息数组中缺少用户消息，无法进行API调用');
          throw new Error('消息结构不完整，缺少用户消息');
        }
        
        // 确保用户消息包含图片数据 (如果有上传图片)
        if (image) {
          const userMessage = messages.find(msg => msg.role === 'user');
          if (!userMessage) {
            logger.error('无法找到用户消息');
            throw new Error('消息结构错误，缺少用户消息');
          }
          
          if (!Array.isArray(userMessage.content)) {
            logger.error('用户消息内容不是数组格式');
            throw new Error('用户消息格式错误，应为数组格式');
          }
          
          const hasImage = userMessage.content.some(item => item.type === 'image_url');
          if (!hasImage) {
            logger.error('用户消息中缺少图片数据');
            throw new Error('图片数据丢失，请重新上传图片');
          }
          
          logger.info('消息结构验证通过，包含用户图片数据');
        }
        
        // 重要：在执行API调用前，将任务状态从pending更新为processing
        try {
          const { error: statusUpdateError } = await supabaseAdmin
            .from('image_tasks')
            .update({
              status: 'processing',
              updated_at: new Date().toISOString()
            })
            .eq('task_id', taskId);
          
          if (statusUpdateError) {
            logger.error(`更新任务状态为processing失败: ${statusUpdateError.message}`);
            // 继续执行，不中断流程，但记录错误
              } else {
            logger.stateChange(taskId, 'pending', 'processing');
            logger.info(`已更新任务状态为processing, 任务ID: ${taskId}`);
          }
        } catch (statusError) {
          logger.error(`更新任务状态异常: ${statusError instanceof Error ? statusError.message : String(statusError)}`);
          // 继续执行，不中断流程
        }
        
        // 定义重试逻辑所需的变量
        const MAX_RETRY_ATTEMPTS = 2; // 最大重试次数
        let currentAttempt = 0;
        let lastError = null;
        
        // 使用主方法 - GPT-4o聊天API生成图像
        logger.info('尝试使用GPT-4o聊天API生成图像');
        
        try {
          // 重试逻辑
          while (currentAttempt <= MAX_RETRY_ATTEMPTS) {
            try {
              // 如果不是首次尝试，记录重试信息并更新尝试次数
              if (currentAttempt > 0) {
                logger.info(`进行第${currentAttempt}次重试，任务ID: ${taskId}`);
                
                // 更新数据库中的尝试次数
                const { error: attemptError } = await supabaseAdmin
                  .from('image_tasks')
                  .update({
                    attempt_count: currentAttempt,
                    updated_at: new Date().toISOString()
                  })
                  .eq('task_id', taskId);
                
                if (attemptError) {
                  logger.error(`更新尝试次数失败: ${attemptError.message}`);
                }
              }
              
              // 设置超时处理
              const API_TIMEOUT = parseInt(process.env.OPENAI_TIMEOUT || '60000');
              const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => {
                  reject(new Error(`API请求超时，超过${API_TIMEOUT/1000}秒未响应`));
                }, API_TIMEOUT);
              });
              
              // 增强的URL提取函数，可以提高URL检测率
              const extractUrlWithFullPatterns = (text: string): string | null => {
                if (!text || typeof text !== 'string') return null;
                
                // 尝试多种URL提取模式
                const patterns = [
                  // JSON结构中的URL
                  /"image_url"\s*:\s*"(https?:\/\/[^"]+)"/i,
                  // Markdown格式
                  /!\[.*?\]\((https?:\/\/[^\s)]+)\)/i,
                  // HTML图片标签
                  /<img.*?src=["'](https?:\/\/[^\s"']+)["']/i,
                  // 直接URL
                  /(https?:\/\/[^\s]+\.(?:png|jpg|jpeg|gif|webp)(?:\?[^\s]*)?)/i,
                  // 通用URL模式
                  /(https?:\/\/[^\s"'<>]+)/i,
                  // 带有特定域名的URL
                  /(https?:\/\/\w+\.(?:cloudfront|akamaized|staticflickr|googleusercontent|openai)\.(?:net|com|org)\/[^\s]+)/i
                ];
                
                for (const pattern of patterns) {
                  const match = text.match(pattern);
                  if (match && match[1]) {
                    logger.debug(`使用模式 ${pattern} 提取到URL: ${match[1]}`);
                    return match[1];
                  }
                }
                
                return null;
              };
              
              // 执行API调用 - 严格按照tuzi-openai.md的方式
              const apiPromise = openaiClient.chat.completions.create({
                model: 'gpt-4o-all',
                messages: messages,
                stream: true,
              });
                  
              // 记录发送的消息结构和内容
              logger.debug(`发送到API的消息数量: ${messages.length}`);
              if (messages.length > 0 && messages[0].role === 'user') {
                if (typeof messages[0].content === 'string') {
                  logger.debug(`用户消息内容: ${messages[0].content.substring(0, 200)}...`);
                } else if (Array.isArray(messages[0].content)) {
                  const textContent = messages[0].content.find(item => item.type === 'text');
                  if (textContent && 'text' in textContent) {
                    logger.debug(`用户文本内容: ${textContent.text.substring(0, 200)}...`);
                  }
                  logger.debug(`消息包含图片: ${messages[0].content.some(item => item.type === 'image_url')}`);
                }
              }
              
              // 竞争：API调用 vs 超时
              const stream = await Promise.race([
                apiPromise,
                timeoutPromise
              ]) as any; // 使用any类型，因为Promise.race会返回多种可能类型
              
              logger.info(`请求成功完成，使用gpt-4o-all模型生成图像，使用单一用户消息包含所有指令`);
              logger.timing(apiRequestStartTime, `API请求完成`);
              
              // 收集响应内容
              let responseContent = '';
              let imageUrl = null;
              
              // 处理流式响应 - 按照tuzi-openai.md处理方式
              for await (const chunk of stream) {
                const content = chunk.choices[0]?.delta?.content || '';
                if (content) {
                  responseContent += content;
                  process.stdout.write(content); // 输出流式内容到控制台
                  
                  // 尝试从内容中提取图片URL
                  if (!imageUrl && content.includes('http')) {
                    const extractedUrl = extractUrlWithFullPatterns(content);
                    if (extractedUrl) {
                      imageUrl = extractedUrl;
                      logger.info(`从流中提取到图片URL: ${imageUrl}`);
                    }
                  }
                }
              }
              
              // 如果没有从流中提取到图片URL，从整个响应内容中尝试提取
              if (!imageUrl && responseContent) {
                logger.debug('尝试从完整的响应内容中提取URL');
                imageUrl = extractUrlWithFullPatterns(responseContent);
                if (imageUrl) {
                  logger.info(`从完整响应中提取到图片URL: ${imageUrl}`);
                }
              }
              
              // 验证提取的URL是否有效
              if (imageUrl) {
                logger.info(`成功提取图片URL: ${imageUrl}`);
                
                // 验证是否是有效的图像URL
                if (!isValidImageUrl(imageUrl)) {
                  logger.warn(`提取的URL不是有效的图像URL: ${imageUrl}`);
                  
                  // 查找任何可能的图像URL
                  if (responseContent) {
                    const backupUrl = extractImageUrl(responseContent);
                    if (backupUrl && isValidImageUrl(backupUrl)) {
                      imageUrl = backupUrl;
                      logger.info(`找到备用有效图像URL: ${imageUrl}`);
                    }
                  }
                }
                
                // 如果找到有效的图像URL，更新任务状态并返回
                if (imageUrl && isValidImageUrl(imageUrl)) {
                  logger.info(`成功提取有效的图片URL: ${imageUrl}`);
                  
                  // 更新任务状态为成功
                  try {
                    const { error: updateError } = await supabaseAdmin
                      .from('image_tasks')
                      .update({
                        status: 'completed',
                        provider: 'tuzi',
                        image_url: imageUrl,
                        updated_at: new Date().toISOString()
                      })
                      .eq('task_id', taskId);
                    
                    if (updateError) {
                      logger.error(`更新任务状态失败: ${updateError.message}`);
                    } else {
                      logger.stateChange(taskId, 'processing', 'completed');
                      logger.info(`成功更新任务状态为completed, 任务ID: ${taskId}`);
                    }
                  } catch (updateError: unknown) {
                    logger.error(`更新任务状态异常: ${updateError instanceof Error ? updateError.message : String(updateError)}`);
                  }
                  
                  // 记录生成历史
                  await saveGenerationHistory(supabaseAdmin, currentUser.id, imageUrl, finalPrompt, style, aspectRatio, standardAspectRatio)
                    .catch(historyError => 
                      logger.error(`记录生成历史失败: ${historyError instanceof Error ? historyError.message : String(historyError)}`)
                    );
                    
                  // 发送任务完成通知
                  await notifyTaskUpdate(taskId, 'completed', imageUrl)
                    .catch(notifyError => 
                      logger.error(`发送任务完成通知失败: ${notifyError instanceof Error ? notifyError.message : String(notifyError)}`)
                    );
                    
                  // 完成整个过程，记录总耗时
                  logger.timing(startTime, `整个图像生成任务完成，任务ID: ${taskId}`);
                  
                  // 返回成功响应
                  return NextResponse.json({ 
                    taskId, 
                    status: 'success',
                    imageUrl: imageUrl,
                    prompt: finalPrompt,
                    style: style || null,
                    model: 'gpt-4o-all',
                    provider: 'tuzi'
                  }, { status: 200 });
                }
              } else {
                // 如果没有找到有效URL，记录详细日志并抛出错误
                logger.error(`所有方法都无法提取有效的图片URL，响应内容: ${responseContent?.substring(0, 200)}...`);
                throw new Error('API返回的响应中没有包含有效的图像生成结果');
              }
            } catch (attemptError) {
              lastError = attemptError;
              const errorMsg = attemptError instanceof Error ? attemptError.message : String(attemptError);
              
              // 判断是否需要重试的错误类型
              const shouldRetry = 
                errorMsg.includes('timeout') || 
                errorMsg.includes('超时') ||
                errorMsg.includes('rate limit') ||
                errorMsg.includes('too many requests') ||
                errorMsg.includes('服务暂时不可用') ||
                errorMsg.includes('temporary failure') ||
                errorMsg.includes('500 Internal Server Error') ||
                errorMsg.includes('503 Service Unavailable');
              
              // 如果当前已达到最大重试次数，或者错误类型不适合重试，则抛出
              if (currentAttempt >= MAX_RETRY_ATTEMPTS || !shouldRetry) {
                logger.error(`不再重试，错误为: ${errorMsg}`);
                throw attemptError;
              }
              
              // 计算退避时间 (1秒, 3秒, 9秒...)
              const backoffTime = Math.pow(3, currentAttempt) * 1000;
              logger.info(`API请求失败，将在${backoffTime/1000}秒后重试: ${errorMsg}`);
              
              // 等待退避时间
              await new Promise(resolve => setTimeout(resolve, backoffTime));
              
              // 增加尝试次数并继续循环
              currentAttempt++;
            }
          }
        } catch (mainApiError) {
          // 所有重试都失败，直接更新任务状态为失败
          const errorMsg = mainApiError instanceof Error ? mainApiError.message : String(mainApiError);
          logger.error(`图像生成失败: ${errorMsg}`);
        
        // 更新任务状态为失败
          try {
            const { error: updateError } = await supabaseAdmin
              .from('image_tasks')
              .update({
                status: 'failed',
                error_message: errorMsg.substring(0, 1000), // 限制错误消息长度
                updated_at: new Date().toISOString()
              })
              .eq('task_id', taskId);
              
            if (updateError) {
              logger.error(`更新任务状态为failed失败: ${updateError.message}`);
            } else {
              logger.stateChange(taskId, 'processing', 'failed');
              logger.info(`已更新任务状态为failed, 任务ID: ${taskId}`);
            }
          } catch (updateError) {
            logger.error(`更新失败状态异常: ${updateError instanceof Error ? updateError.message : String(updateError)}`);
          }
          
          // 尝试发送任务状态更新通知
          await notifyTaskUpdate(taskId, 'failed', undefined, errorMsg)
            .catch(notifyError => 
              logger.error(`发送失败通知失败: ${notifyError instanceof Error ? notifyError.message : String(notifyError)}`)
            );
          
          throw new Error(`图像生成失败: ${errorMsg}`);
      }
    } catch (error) {
      // 错误处理 - 回滚点数
      console.error('创建任务失败，尝试回滚点数:', error);
      
      try {
        // 使用类型断言处理
        const creditsObject = credits as { credits: number } | null | undefined;
        
        if (!creditsObject) {
          console.log('无法回滚用户点数：credits对象为null或undefined');
        } else if (typeof creditsObject.credits === 'number') {
          await supabaseAdmin
            .from('ai_images_creator_credits')
            .update({
              credits: creditsObject.credits,
              updated_at: new Date().toISOString()
            })
            .eq('user_id', currentUser.id);
            
          console.log('成功回滚用户点数');
        } else {
          console.log('无法回滚用户点数：credits.credits不是有效的数字');
        }
      } catch (rollbackError) {
        console.error('回滚用户点数失败:', rollbackError);
      }
      
      // 返回错误响应
      return NextResponse.json({
        status: 'failed',
        error: '创建图像任务失败',
        details: error instanceof Error ? error.message : String(error)
      }, { status: 500 });
    }
  } catch (error) {
    console.error(`处理图像生成请求失败:`, error);
    
    // 判断错误类型，提供更友好的错误信息
    let status = 500;
    let errorMessage = '创建图像任务失败';
    let suggestion = '请稍后重试';
    
    if (error instanceof Error) {
      if (error.message.includes('JSON')) {
        status = 400;
        errorMessage = '无效的请求格式';
        suggestion = '请确保发送的是有效的JSON数据';
      } else if (error.message.includes('点数')) {
        status = 402;
        errorMessage = error.message;
        suggestion = '请充值点数或联系客服';
      } else if (error.message.includes('大小') || error.message.includes('尺寸')) {
        status = 413;
        errorMessage = error.message;
        suggestion = '请减小图片尺寸或降低质量后重试';
      }
    }
    
    return NextResponse.json(
      { 
        status: 'failed',
        error: errorMessage, 
        suggestion,
        details: error instanceof Error ? error.message : String(error) 
      },
      { status }
    );
  }
}
